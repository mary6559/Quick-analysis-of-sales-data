{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "6d702d3e-6d4b-4cad-a9fd-ff5c8ce75c5e",
   "metadata": {},
   "source": [
    "# Quick analysis of sales data with directory verification"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "58c28ea3-7547-4174-a0a5-7018a9b84ef8",
   "metadata": {},
   "source": [
    "Description:\n",
    "\n",
    "You received two CSV files: one containing sales data from the last quarter, and another with the current product catalog and their listed prices.\n",
    "Your task is to quickly analyze this data and answer key questions from the management, taking into account potential discrepancies between the sales report and the catalog."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "37716bdc-fe96-49c8-a1e6-061e4e67e4fc",
   "metadata": {},
   "source": [
    "## Task 1 \n",
    "\n",
    "Merge the sales data with the product catalog. How many unique transactions from the file raport_kwartalny_sprzedaz.csv do not have a corresponding entry in katalog_produktow.csv based on the Product ID column?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "6bc73f98-39d6-4315-a609-15769d79cf04",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "146\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "\n",
    "sprzedaz_id = '1wl5QaazaxOkToVbVZwEcaMuvcZjBeM1a'\n",
    "katalog_id = '1wTFPyNfaQOg3scLpG9z9h7zomIwfZi8X'\n",
    "\n",
    "url_sprzedaz = f'https://drive.google.com/uc?id={sprzedaz_id}'\n",
    "url_katalog = f'https://drive.google.com/uc?id={katalog_id}'\n",
    "\n",
    "df = pd.read_csv(url_sprzedaz)\n",
    "df1 = pd.read_csv(url_katalog)\n",
    "\n",
    "merged_df = pd.merge(\n",
    "    df,\n",
    "    df1,\n",
    "    how='left',\n",
    "    left_on='ID_Produktu_Sprzedaz',\n",
    "    right_on='ID_Produktu_Katalog',\n",
    "    indicator=True\n",
    ")\n",
    "\n",
    "unmatched_transactions = merged_df[merged_df['_merge'] == 'left_only']\n",
    "\n",
    "import numpy as np\n",
    "\n",
    "print(len(np.unique(unmatched_transactions['ID_Produktu_Sprzedaz'])))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c875f824-9906-4e74-ad09-40160f7f04de",
   "metadata": {},
   "source": [
    "### What am I doing?\n",
    "\n",
    "-I import the necessary libraries and the files (data sources) I’ll be working with.\n",
    "\n",
    "-Then I read the .csv files containing the sales data and the product catalog.\n",
    "\n",
    "-I merge both tables using pd.merge() – I specify:\n",
    "\n",
    "    -the names of the tables to be joined,\n",
    "\n",
    "    -the type of join (left join, to keep all rows from the sales data and insert NaN if no match is found in the catalog),\n",
    "\n",
    "    -the common column used for the join (e.g. Product ID),\n",
    "\n",
    "    -and I add an indicator column to later filter unmatched entries.\n",
    "\n",
    "-I search for unmatched transactions (i.e. ones that did not find a match in the second table) using the _merge indicator, filtering only rows marked as \"left_only\" – meaning they exist in the sales data but not in the catalog.\n",
    "\n",
    "-I use the NumPy library to find the unique values, ensuring that I’m counting distinct unmatched transactions."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7e025509-df6b-4847-b2cb-e183c3b44143",
   "metadata": {},
   "source": [
    "## Task 2\n",
    "\n",
    "What is the total sales value in the entire report (Wartosc_Sprzedazy from the file raport_kwartalny_sprzedaz.csv), considering only those transactions for which a matching product was found in the catalog?\n",
    "\n",
    "Present the result rounded to two decimal places."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "f2c4d53b-d0e2-48f3-adc9-ce98f9ca1016",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Index(['Data_Transakcji', 'ID_Produktu_Sprzedaz', 'Region', 'Ilosc_Sprzedana',\n",
      "       'Cena_Jednostkowa_Transakcji', 'Wartosc_Sprzedazy'],\n",
      "      dtype='object')\n"
     ]
    }
   ],
   "source": [
    "print(df.columns)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "010e29b5-97cf-4082-8a3c-6b5a91a719cc",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Index(['ID_Produktu_Katalog', 'Nazwa_Produktu', 'Cena_Katalogowa',\n",
      "       'Kategoria_Produktu'],\n",
      "      dtype='object')\n"
     ]
    }
   ],
   "source": [
    "print(df1.columns)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "cf2c3371-56b0-476f-8982-ea8b8d54f6d9",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "31336539.21\n"
     ]
    }
   ],
   "source": [
    "df_merged1 = pd.merge(\n",
    "    df, \n",
    "    df1, \n",
    "    left_on='ID_Produktu_Sprzedaz', \n",
    "    right_on='ID_Produktu_Katalog', \n",
    "    how='inner')\n",
    "total_sales = df_merged1['Wartosc_Sprzedazy'].sum()\n",
    "print(round(total_sales, 2))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e6166af4-8218-4f84-9081-f5b420e327b3",
   "metadata": {},
   "source": [
    "### What am I doing?\n",
    "\n",
    "-I merge both tables just like in the previous task, but this time I set the how parameter to \"inner\" so that only the rows with matching entries in both the sales report and the product catalog are kept (ensuring no missing values).\n",
    "\n",
    "-Thanks to this, each row has a matching product with a valid value, and I can safely calculate the total sales value using .sum() on the Wartosc_Sprzedazy column.\n",
    "\n",
    "-Finally, I round the result to two decimal places."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "09a47f54-f0c4-4630-8c36-cb9eb76507af",
   "metadata": {},
   "source": [
    "## Task 3a\n",
    "\n",
    "Which \"Nazwa_Produktu\" (from the catalog) has the largest percentage difference between the average Cena_Jednostkowa_Transakcji (from the sales report) and the Cena_Katalogowa (from the catalog)?\n",
    "\n",
    "Return the product name only."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "0b7becc6-cf1c-4547-a256-bdea4f3f3f66",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Miara Przyczyna\n"
     ]
    }
   ],
   "source": [
    "df_merged3 = pd.merge(\n",
    "    df,\n",
    "    df1,\n",
    "    left_on='ID_Produktu_Sprzedaz',\n",
    "    right_on='ID_Produktu_Katalog',\n",
    "    how='inner')\n",
    "\n",
    "srednie_ceny = df_merged3.groupby('Nazwa_Produktu')['Cena_Jednostkowa_Transakcji'].mean().reset_index()\n",
    "\n",
    "srednie_ceny.rename(columns={'Cena_Jednostkowa_Transakcji': 'Srednia_Cena_Transakcji'}, inplace=True)\n",
    "\n",
    "srednie_ceny = pd.merge(\n",
    "    srednie_ceny,\n",
    "    df1[['Nazwa_Produktu', 'Cena_Katalogowa']],\n",
    "    on='Nazwa_Produktu',\n",
    "    how='left')\n",
    "\n",
    "srednie_ceny['Procentowa_Roznica'] = (\n",
    "    (srednie_ceny['Srednia_Cena_Transakcji'] - srednie_ceny['Cena_Katalogowa'])\n",
    "    / srednie_ceny['Cena_Katalogowa']\n",
    ") * 100\n",
    "\n",
    "max_diff_row = srednie_ceny.iloc[srednie_ceny['Procentowa_Roznica'].abs().idxmax()]\n",
    "\n",
    "print(max_diff_row['Nazwa_Produktu'])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "269f335b-9000-4dac-b15f-1ca84329b016",
   "metadata": {},
   "source": [
    "### What am I doing?\n",
    "\n",
    "-I merge the two tables in such a way that only rows with matching product IDs on both sides are included.\n",
    "\n",
    "-I calculate the average unit price per product by grouping the sales data by product name and computing the mean of Cena_Jednostkowa_Transakcji. Then I reset the index to turn the product name back into a regular column, so I can work with it more easily.\n",
    "\n",
    "-I rename the Cena_Jednostkowa_Transakcji column to make the data clearer and avoid confusion about what the values represent.\n",
    "\n",
    "-I merge the resulting average prices with the catalog prices from the second table, joining on the product name, so I can compare them directly.\n",
    "\n",
    "-I calculate the percentage difference between the average transaction price and the catalog price, and I add this as a new column to the table.\n",
    "\n",
    "-I find the product with the largest percentage difference using .idxmax() to get the row index with the maximum absolute difference, and then .iloc to retrieve the product's name from that row.\n",
    "\n",
    "-I use .abs() in the calculation to make sure the result reflects the biggest deviation, regardless of whether the difference is positive or negative."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "de4ed950-133e-4c00-8af4-228700bea42e",
   "metadata": {},
   "source": [
    "## Task 3b\n",
    "\n",
    "What is the percentage difference from Task 3a?\n",
    "\n",
    "Provide the percentage difference including the sign:\n",
    "\n",
    "    \"+\" if the average unit transaction price is higher than the catalog price,\n",
    "\n",
    "    \"-\" if it is lower."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "414ad7d1-49fd-4008-ac0e-2e45ff19b59a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "-29.999534710589987\n",
      "-30.0\n"
     ]
    }
   ],
   "source": [
    "roznica_procent = max_diff_row['Procentowa_Roznica']\n",
    "\n",
    "print(roznica_procent)\n",
    "\n",
    "print(round(roznica_procent, 2))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "841a28ed-114f-4c56-bd01-b65bec6172b1",
   "metadata": {},
   "source": [
    "### What am I doing?\n",
    "\n",
    "-Based on the previously calculated maximum percentage difference, I retrieve that value,\n",
    "\n",
    "-Then round it to make it more readable and easier to interpret.\n",
    "\n",
    "This value already includes the sign (positive or negative), which indicates whether the average transaction price is higher or lower than the catalog price."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "816aef4d-62eb-42bf-b976-6940f13918d7",
   "metadata": {},
   "source": [
    "## Task 4\n",
    "\n",
    "How many rows in the sales report contain a mismatch between Wartosc_Sprzedazy and the product of Ilosc_Sprzedana * Cena_Jednostkowa_Transakcji?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "4348609f-0ca3-48ee-a208-90f094f8f0ac",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1239\n"
     ]
    }
   ],
   "source": [
    "df['Iloczyn'] = df['Ilosc_Sprzedana'] * df['Cena_Jednostkowa_Transakcji']\n",
    "\n",
    "niezgodne = df[~(df['Wartosc_Sprzedazy'] == df['Iloczyn'])]\n",
    "\n",
    "print(len(niezgodne))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "00add400-8c78-422f-b52c-8893b81737d2",
   "metadata": {},
   "source": [
    "### What am I doing?\n",
    "\n",
    "-I calculate the product specified in the task: Ilosc_Sprzedana * Cena_Jednostkowa_Transakcji.\n",
    "\n",
    "-Then, I compare this calculated value with the Wartosc_Sprzedazy column to check for mismatches.\n",
    "\n",
    "-I use the ~ operator to invert the match condition, selecting only the rows where the values do not match.\n",
    "\n",
    "-Finally, I count the number of mismatched rows, which gives me the total number of discrepancies in the report."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "b94ad81b-4ea0-4961-a1cb-3bc962a1cc32",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "373\n"
     ]
    }
   ],
   "source": [
    "niezgodne1 = df[~df['Wartosc_Sprzedazy'].round(2).eq(df['Iloczyn'].round(2))]\n",
    "\n",
    "print(len(niezgodne1))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4f14da05-e23a-4f18-b5d2-f860e894266b",
   "metadata": {},
   "source": [
    "### What am I doing?\n",
    "\n",
    "I round both the calculated product (Ilosc_Sprzedana * Cena_Jednostkowa_Transakcji) and the Wartosc_Sprzedazy value to 2 decimal places.\n",
    "\n",
    "This helps to avoid small discrepancies caused by floating-point precision, rounding errors, or technical formatting issues (like fractions of a cent)."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8c1e66d6-8237-49e1-ac92-fd953e058445",
   "metadata": {},
   "source": [
    "## Task 5a\n",
    "\n",
    "In the case of mismatches detected in question 4, which of the two values seems more reliable for reporting purposes?\n",
    "\n",
    "    A: Wartosc_Sprzedazy from the sales report file\n",
    "\n",
    "    B: the calculated value: Ilosc_Sprzedana * Cena_Jednostkowa_Transakcji"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4307906b-0979-443d-8d80-b51a7b3ba626",
   "metadata": {},
   "source": [
    "B: Ilosc_Sprzedana * Cena_Jednostkowa_Transakcji"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "222f8505-b5b1-42cc-81d3-2dff7ae17b1b",
   "metadata": {},
   "source": [
    "## Task 5b\n",
    "\n",
    "Justify the answer provided in the previous question."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "47ba1de0-2cfc-4724-86ad-e6effac709a2",
   "metadata": {},
   "source": [
    "In my opinion, Value B – the result of Ilosc_Sprzedana * Cena_Jednostkowa_Transakcji – is more reliable for reporting purposes, because it’s less prone to error as it’s based on a straightforward mathematical calculation.\n",
    "\n",
    "Value A, on the other hand, may contain mistakes – for example, due to manual data entry, or it might include discounts that aren't visible in other columns.\n",
    "With Value B, we’re relying on two separate numeric fields that are easier to verify and validate independently."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:base] *",
   "language": "python",
   "name": "conda-base-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
